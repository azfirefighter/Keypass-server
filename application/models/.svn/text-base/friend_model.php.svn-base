<?php
class Friend_model extends CI_Model {
    public function __construct()
    {
        parent::__construct();
    }
	
	/*
	 * Retourne un tableau des applis des amis
	 * dont on passe les UUIDS en paramètres,
	 * ainsi que l'os
	 */
	public function get_apps($uuids, $os_id, $index = 0)
	{
		$this->db->select('app.app_id, app.app_store_id, app.app_title, app.app_editor, app.app_link, app.app_rating, app.app_short_desc, app.app_description, app.app_thumbnail, app.app_picture, app.app_screen_1, app.app_screen_2, app.app_screen_3, fri.fri_uuid,  UNIX_TIMESTAMP(fri.fri_date_added) AS date_added, app.app_price')
					->from('admin_app AS app')
					->join('fb_friend_app AS fri', 'app.app_id = fri.app_id')
					->where('app.app_os_id', $os_id)
					->where_in('fri.fri_uuid', $uuids)
					->order_by('app.app_id', 'asc');
		$query = $this->db->get();
		$request = $query->result_array(); // on ne peut pas faire de group by comme on veut tous les uuids
		
		$length = $query->num_rows();
		
		if ($length == 0)
		{
			return array(); // if array empty, go out
		}
		
		// boucle de déduplication & compte
		for ($i=0;$i<$length;$i++)
		{
			$amis[$request[$i]['fri_uuid']] = $request[$i]['date_added'];
			
			if (( ! isset($request[$i+1])) || ($request[$i]['app_id'] != $request[$i+1]['app_id']))
			{
				$apps[] = array_merge($request[$i], array('count' => count($amis), 'fri_uuid' => $amis));
				$amis = array();
			}
		}
		
		// on trie le tableau ; il faut faire un tableau avec les valeurs à trier avant
	    foreach ($apps as $app) {
	        $count[] = $app['count'];
	    }
		array_multisort($count, SORT_DESC, $apps);
		
		$apps = array_slice($apps, $index, 10);
		
		return $apps;
	}

	/*
	 * Presque pareil, mais avec un seul uuid
	 */
	public function get_my_apps($uuid, $os_id)
	{
		$this->db->select('app.app_id, app.app_store_id, app.app_title, app.app_editor, app.app_link, app.app_rating, app.app_short_desc, app.app_description, app.app_thumbnail, app.app_picture, app.app_screen_1, app.app_screen_2, app.app_screen_3, app.app_price')
					->from('admin_app AS app')
					->join('fb_friend_app AS fri', 'app.app_id = fri.app_id')
					->where('app.app_os_id', $os_id)
					->where('fri.fri_uuid', $uuid)
					->order_by('app.app_id', 'asc');
		$query = $this->db->get();
		$apps = $query->result_array(); // on ne peut pas faire de group by comme on veut tous les uuids
		
		return $apps;		
	}
	
	/*
	 * CRUD avec un item
	 */
	/*
	 * dans fb_friend (uuids)
	 */
	// créé un ami, ou s'il existe déjà met à jour le champ last_modified
	public function add_or_update_friend($uuid, $date)
	{
		// on regarde s'il n'y a pas déjà quelqu'un, auquel cas on update last_modified
        $sql = 'INSERT INTO fb_friend (fri_uuid,fri_last_modified) VALUES (?, FROM_UNIXTIME(?)) ON DUPLICATE KEY UPDATE fri_last_modified = FROM_UNIXTIME(?)';
        $query = $this->db->query($sql, array($uuid, $date, $date));
	}
	/*
	 * dans fb_friend_app :
	 * relations entre des amis et des applis
	 */
	public function add_friend_app($uuid, $app_id, $date)
	{
		// toutes les données qu'on a reçu sont safes
		// par contre, la relation peut déjà exister,
        $sql = 'INSERT IGNORE INTO fb_friend_app (fri_uuid, app_id, fri_date_added) VALUES (?, ?, FROM_UNIXTIME(?))';
        $query = $this->db->query($sql, array($uuid, $app_id, $date));
	}
	public function delete_friend_app($uuid, $app_id)
	{
		$this->db->delete('fb_friend_app', array('fri_uuid' => $uuid, 'app_id' => $app_id)); 
	}
	
}
/* EOF */